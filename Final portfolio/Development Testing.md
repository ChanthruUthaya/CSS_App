#Development Testing
###Testing Strategy
The first stages of the development for our app was producing XML files and designing the layouts for each of our separate activities. Once we had finished creating them, we would write unit tests that verify each component works as intended as well as check the layout is consistent and stable. For example a test to make sure a text box works as intended would consist of finding the textbox view using a view matcher, performing an action (e.g. typing hello) and then asserting that the textbox displays the text “hello”. Each of the individual pages within the client component of our UML architecture model is an activity class within our project. For each activity we hve a corresponding testing class that was concerned with only testing the functionality of that activity.This meant we could keep our tests contained so when conducting integration tests each of the tests would not interfere with one another. An integration test would be conducted when a group of components in our activity and layout had been fully implemented. The writing of a test consisted of simulating use of those components and asserting the final outcome is as expected.

We tested the database by storing in the values and information from the “Create Profile” activity. For each value entered, we confirmed it properly enters the database in the appropriate section by looking into the database after introducing the value through the application. This was unique for each type of input field. Once the data were safely introduced into the database, we used the “Profile” activity to check it could all be obtained from the database and represented in the application. We have also ran our app through Firebase’s own “Test Lab” feature, which has emulated the use of our app on a series of different virtual devices. During the process, the “Robo test” undertook around 100 actions per activity and, at the end, all tests were marked as “passed”.
###Testing frameworks
The main testing framework we are going to use is JUnit. We used the espresso framework as a way of implementing tests for our app. Espresso is a testing framework provided by Android Studio, and it provides us a reliable way of testing the apps front-end UI .To aid us in understanding the workflow, we designed a wireframe with pen and paper which included all the activities we had planned to implement, making it easier to formulate an idea of how the front-end of the application should work and how we should write the tests. These were used when writing Unit and Integration tests. Our testing strategy was to write tests along with the backend and frontend writing. As soon as we've implemented a function, we treated it as a black box, wrote a functional test for it and verified the function is working correctly by checking its output.
###Challenges
One of the problems we encountered while testing was testing of some of the components such as ListViews. When checking if the ListView has contained the proper data, we were incapable of matching the data in the list for the adapter to its specific corresponding ChildView in the ListView. To get around this we had to write a test that manually scrolled through the ListView and matched the text of the data to anything within the View’s hierarchy. Whilst this achieves a similar goal, it is a far less elegant solution for testing the ListView. When testing the database and a problem arose, debugging our code remained a long process. It was hard to locate the problem, and we had to use logs on every function to test which ones were working as intended and which ones weren't. From there we could deduce the problem.
